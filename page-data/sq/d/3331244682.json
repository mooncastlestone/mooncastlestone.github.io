{"data":{"allMarkdownRemark":{"nodes":[{"id":"97538da8-1463-5d46-9ea9-a5833f1e4689","frontmatter":{"title":"HTTP와 HTTPS의 차이점","date":"2020-07-25","slug":"/interview/post-2/","description":"HTTP와 HTTPS의 차이점에 대해서 정리하였습니다."},"html":"<p>HTTP와 HTTPS의 가장 큰 차이점은 보안 소켓 계층의 유무이다.</p>\n<p>보안 소켓 계층에 대해서 정리하기 전에 우선 HTTP가 어떤 것인지부터 정리를 해보자.\n<br></br></p>\n<h2>HTTP란?</h2>\n<p><strong>Hyper Text Transfer Protocal</strong>의 약자로 웹 상에서 클라이언트와 서버가 서로 정보를 주고 받기 위해 만들어진 가장 기본적인 프로토콜이라고 한다. 그렇다면 프로토콜은 무엇인가?\n<br></br></p>\n<h2>프로토콜이란?</h2>\n<p>프로토콜이란 컴퓨터 내부에서, 혹은 컴퓨터들 사이에서 데이터를 교환하는 방식을 정의하는 규칙체계이다. 이 HTTP 규칙에 맞게 모든 웹사이트들이 데이터 통신을 주고 받았었다. 그런데 이 HTTP에서도 문제점이 있었는데, 바로 보안에 취약하다는 점이었다. 브라우저와 서버가 데이터가 암호화가 되어 있지 않아, 제 3자가 수정, 삭제, 탈취가 가능했었다.</p>\n<p>이러한 문제점을 해결하기 위해 나온 것이 HTTPS이다.\n<br></br></p>\n<h2>HTTPS란?</h2>\n<p>간단하게 말해서 HTTP에 보안 기능이 추가된 것이다. HTTPS는 기존 HTTP에 보안 소켓 계층을 적용하여 보안을 향상시킨 프로토콜이다.</p>\n<p>그렇다면 이제 보안 소켓 계층에 대해서 정리해보자.\n<br></br></p>\n<h2>보안 소켓 계층이란?</h2>\n<p>보안 소켓 계층이란, Secure Sockets Layer의 약자로, 웹사이트와 브라우저 사이에 전송된 데이터를 암호화하여 보안을 유지하는 표준 기술이라고 한다.\n<br></br></p>\n<p>정리하자면, HTTPS는 기존 HTTP 프로토콜에 SSL을 적용하여 <strong>서버와 클라이언트 사이의 모든 통신 내용을 암호화할 수 있는 프로토콜이라고 생각하면 될 것 같다.</strong> 그렇다면 이 HTTPS의 장점은 어떤 것들이 있을까?\n<br></br></p>\n<h2>HTTPS 장점</h2>\n<p><strong>1. 보안</strong></p>\n<p>앞서 보안에 대해서 언급했듯이, HTTPS로 적용되어져있는 사이트에서는 사용자가 민감한 정보를 제공한다고 해도 암호화가 되어져 있기 때문에, 제 3자가 데이터를 탈취한다고 하더라도 해독을 할 수가 없다.\n<br></br>\n<strong>2. 검색 엔진 품질 향상</strong></p>\n<p>만약 운영하는 웹사이트가 전자상거래 기능도 없고 방문자들의 민감한 정보를 다루지도 않는다면, HTTPS로 전환할 필요성을 크게 느끼지 못할 것이다. 하지만 HTTPS의 장점은 보안에만 있는 것은 아니다. 2014년 구글에서 HTTP를 HTTPS로 바꾸라고 권고를 하면서, HTTPS를 적용한 웹사이트에 대해서 검색 순위 결과에 약간의 가산점을 주겠다고 발표를 하였다. 따라서, HTTPS를 적용하면 검색엔진 최적화(SEO)에 있어서 혜택을 볼 수 있다.\n<br></br></p>\n<h3>이러한 장점들이 있는데 그렇다면 모든 웹사이트에 HTTPS를 사용해도 될까?</h3>\n<p>암호화를 하지 않은 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스를 더 많이 요구한다. 통신할 때마다 암호화를 하면 추가적인 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 리퀘스트의 수가 상대적으로 줄어들게 된다.\n<br></br>\n하지만 최근에는 <strong>하드웨어의 발달</strong>로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않는다고 한다. 게다가 새로운 표준인 <strong>HTTP 2.0</strong>을 함께 사용한다면 오히려 HTTP보다 빠르게 동작한다고 한다. 따라서 과거의 민감한 정보를 다룰 때에만 HTTPS를 사용하는 방식에서 모든 웹 페이지에 HTTPS를 적용하는 방향으로 바뀌고 있다고 한다.\n<br></br></p>\n<hr>\n<h2>Reference</h2>\n<p><a href=\"http://blog.wishket.com/http-vs-https-%EC%B0%A8%EC%9D%B4-%EC%95%8C%EB%A9%B4-%EC%82%AC%EC%9D%B4%ED%8A%B8%EC%9D%98-%EB%A0%88%EB%B2%A8%EC%9D%B4-%EB%B3%B4%EC%9D%B8%EB%8B%A4/\">http vs https 차이를 알면 사이트의 레벨이 보인다</a></p>\n<p><a href=\"https://eun-jeong.tistory.com/27\">[네트워크] HTTPS (개념, SSL/TLS 암호화 과정, 장단점)</a></p>\n<p><a href=\"https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network\">Interview_Question_for_Beginner(Network)</a>\n<br></br></p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>"},{"id":"eea1d6da-32cb-5669-8eb6-d6a2c1a56914","frontmatter":{"title":"브라우저 동작 원리","date":"2020-08-03","slug":"/interview/post-1/","description":"브라우저가 어떻게 동작이 되는지에 대해서 정리하였습니다."},"html":"<p>이번에는 '브라우저는 어떻게 동작이 되는가?'에 대해서 정리해보려한다.</p>\n<hr>\n<h1>브라우저의 주요 기능</h1>\n<p>브라우저의 주요 기능은 <strong>사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것이다.</strong> 자원은 보통 HTML 문서지만 PDF나 이미지 또는 다른 형태일 수 있다.</p>\n<p>자원의 주소는 *<strong>URI</strong> (Uniform Resource Identifier)에 의해 정해진다.</p>\n<br>\n<blockquote>\n<p>*<strong>URI란?</strong> <br>인터넷 자원을 나타내는 고유 식별자이다. 인터넷에 있는 자료의 id라고 생각하면 좋을 듯하다. ID는 고유한 값을 의미하는 것이므로 URI는 유일해야한다.<br> URL과 URN은 URI에 포함되는 개념이며, URL은 자원의 위치 그리고 URN은 자원의 이름을 의미한다. 브라우저는 <strong>HTML과 CSS 명세에 따라 HTML 파일을 표시</strong>하는데 이 명세는 웹 표준호 기구인 W3C에서 정한다.</p>\n</blockquote>\n<br>\n<h1>브라우저의 기본 구조</h1>\n<img src=\"https://images.velog.io/images/moon3356/post/3af10a2f-4a84-479d-8745-414925f41292/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-03%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%202.11.55.png\">\n<p>브라우저의 주요 구성 요소는 다음과 같다.</p>\n<p>이번 글에서는 렌더링 엔진에 관해서만 알아보려한다.</p>\n<br>\n<h1>렌더링 엔진 동작 과정</h1>\n<p>렌더링 엔진의 역할은 <strong>요청 받은 내용을 브라우저 화면에 표시하는 일</strong>이다.</p>\n<p>렌더링 엔진 동작 과정은 아래와 같다.</p>\n<br>\n<p><img src=\"https://images.velog.io/images/moon3356/post/601babcb-e874-4269-8349-ba37be166795/Moon.jpg\" alt=\"\">\n<br></p>\n<h3>1. DOM트리 구축 위한 HTML 파싱</h3>\n<p>사용자가 웹사이트에 접속하였을 때, 브라우저는 사용자가 접속한 웹사이트의 서버로부터 HTML 파일을 전달받는다. 이 전달받은 HTML을 브라우저는 *<strong>DOM</strong> 트리 구축을 위해서 *<strong>Parsing</strong>을 진행한다.</p>\n<br>\n<blockquote>\n<p>*<strong>DOM이란?</strong><br>DOM은 <strong>HTML 문서의 객체 기반 표현 방식</strong>이다.둘이 서로 비슷하다고 생각할 수 있지만, DOM이 가지고 있는 근본적인 차이는 단순 텍스트로 구성된 HTML 문서의 내용과 구조가 <strong>객체 모델로 변환</strong>되어 다양한 프로그램에서 사용될 수 있다는 점이다.</p>\n</blockquote>\n<br>\n<blockquote>\n<p>*<strong>Parsing이란?</strong><br><strong>언어학</strong>에서는 Parsing을 **'구문 분석'**이라고 정의한다. 문장을 이루고 있는 구성 성분을 분해하고 그들 사이의 <strong>위계 관계를 분석하여 문장의 구조를 결정</strong>하는 것이 Parsing이다.<br><strong>컴퓨터 공학 관점에서는</strong> 일련의 문자열을 <strong>의미 있는 토큰으로 분해</strong>하고 그것들로 이루어진 <strong>Parse tree를 만드는 과정</strong>이라고 볼 수 있다.<br>브라우저가 웹사이트로 받아온 문서를 이해하고 사용할 수 있는 구조로 변환하는 것을 파싱이라고 생각하면 된다.</p>\n</blockquote>\n<h3>2. 렌더 트리 구축</h3>\n<p>브라우저는 컨텐츠를 담당하는 HTML 파일을 <strong>DOM 트리</strong>로 구축하는 동안, 스타일 규칙을 정의하는 CSS 파일 또한 <strong>CSSOM 트리</strong>로 구축을 한다.</p>\n<p>생성된 DOM 트리와 CSSOM 트리를 합하여 <strong>최종적으로 브라우저에 표기될 것들만 선별하기위해 생성되는 것이 렌더 트리</strong>이다.</p>\n<br>\n<h3>* 렌더 트리가 생성되는 과정</h3>\n<p><strong>1) DOM 트리의 루트로부터 시작하여 노드 각각을 읽으며 표시한다.</strong>\n여기서 메타 태그나 스크립트 태그와 같은 사용자에게 불필요한 정보는 반영되지 않는다. 또한, display:none과 같은 속성을 가진 태그들 또한 제외된다.</p>\n<p><strong>2) 표시된 각 노드에 대해 적절하게 일치하는 CSSOM 규칙을 찾아 적용한다.</strong></p>\n<br>\n<h3>3. 렌더 트리 그리기</h3>\n<p>브라우저가 가지고 있는 구조 중에 하나인 UI 백엔드가 생성된 렌더 트리 노드들을 가로지르며 화면에 스타일이 적용된 컨텐츠들을 그린다.</p>\n<br>\n<h1>중요한 점</h1>\n<p>브라우저에 렌더링하는 위와 같은 과정이 <strong>점진적으로</strong> 진행이 된다. 이 과정에서 렌더링 엔진은 <strong>보다 나은 사용자 경험</strong>을 위해 가능한 빠르게 내용을 표시하는데 <strong>모든 HTML을 파싱하는 과정을 기다리지 않고</strong> 배치와 그리기 과정을 시작한다.</p>\n<br>\n<h1>요약</h1>\n<ol>\n<li>사용자가 접속한 사이트의 자원을 서버로부터 받아온다.</li>\n<li>받아온 HTML과 CSS 파일을 파싱을 통하여 트리 구조로 변환한다.</li>\n<li>변환된 DOM 트리와 CSSOM 트리를 합하여 렌더 트리를 형성하고 렌더링한다.</li>\n</ol>\n<hr>\n<h2>reference</h2>\n<p><a href=\"https://d2.naver.com/helloworld/59361\">브라우저는 어떻게 동작하는가?</a></p>\n<p><a href=\"https://onlydev.tistory.com/9\">렌더 트리</a></p>\n<p><a href=\"https://wit.nts-corp.com/2019/02/14/5522\">DOM은 정확히 무엇일까?</a></p>\n<br>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>"}]}}}