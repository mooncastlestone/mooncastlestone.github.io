{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/javascript/post-1/","result":{"data":{"markdownRemark":{"html":"<h2>변수란?</h2>\n<p>하나의 값을 저장하기 위해 확보한 <strong>메모리 공간 자체</strong> 또는 그 <strong>메모리 공간을 식별</strong>하기 위해 붙인 이름을 말한다. 아무리 복잡한 어플리케이션이라도, 실행되는 흐름은 데이터를 받고, 처리하고, 출력하는 것이 전부이다. <strong>프로그래밍 언어에서 변수는 이러한 데이터를 관리하기 위한 핵심 개념이다.</strong>\n<br></br></p>\n<h2>변수를 이용하는 이유는?</h2>\n<p>메모리를 직접 건드리는 것은 시스템의 치명적 오류를 발생시킬 가능성이 높다. 게다가 메모리에 저장된 값의 주소가 매번 바뀌기 때문에 재사용이 힘들다. 변수를 사용하면 값을 저장할 수 있는 공간을 확보하고 식별할 수 있다.\n<br></br></p>\n<h2>변수 선언, 초기화, 할당 단계</h2>\n<p>변수가 생성되는 과정은 <strong>선언, 초기화, 할당</strong>. 총 3단계를 거쳐 진행이 된다. 선언에 대해서 먼저 알아보자.\n<br></br></p>\n<h3>변수 선언</h3>\n<p>변수 선언 단계에서는 값을 저장하기 위한 <strong>메모리 공간을 확보</strong>한다. 그리고 저장한 메모리를 식별하기 위한 <strong>변수 이름을 설정</strong>하는 것까지 변수 선언 단계에서 진행된다.\n<br></br></p>\n<h3>변수 초기화</h3>\n<p>변수 선언 단계를 거쳐 메모리 공간을 확보한 후에는 해당하는 메모리 공간에 <strong>undefined</strong>를 할당하여 초기화한다.\n<br></br></p>\n<h3>변수 할당</h3>\n<p>초기화 단계까지 마쳐 undefined가 할당된 변수에 원하는 값을 재할당한다.</p>\n<hr></hr>\n<h2>호이스팅이란?</h2>\n<p>소스코드에서 선언된 모든 식별자(변수, 함수, 클래스)들이 유효범위 내 최상단에 마치 끌어올려진 것처럼 동작되는 자바스크립트 고유의 특징이다.\n<br></br></p>\n<h3>호이스팅이 일어나는 과정</h3>\n<p>자바스크립트 엔진이 <strong>코드들을 평가</strong>하면서 호이스팅 적용이 가능한 <strong>모든 식별자(변수, 함수, 클래스 등)들을</strong> <strong>실행 컨텍스트 내부에 저장</strong>을 한다. 이 과정에서 식별자들을 실행 컨텍스트가 관리하는 <strong>스코프</strong>(렉시컬 환경의 환경 레코드)에 등록한다.\n<br></br></p>\n<p>예시 코드와 함께 알아보자.</p>\n<pre class=\"grvsc-container one-dark-pro\" data-language=\"javascript\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">console</span><span class=\"mtk1\">.</span><span class=\"mtk3\">log</span><span class=\"mtk1\">(</span><span class=\"mtk4\">test</span><span class=\"mtk1\">)</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">var</span><span class=\"mtk1\"> </span><span class=\"mtk4\">test</span><span class=\"mtk1\"> </span><span class=\"mtk8\">=</span><span class=\"mtk1\"> </span><span class=\"mtk7\">1</span></span></span></code></pre>\n<p>자바스크립트 엔진이 코드를 평가하는 과정에서 var test;가 실행 컨텍스트가 관리하는 스코프에 저장이 된다. 이때 test 변수는 선언, 초기화 단계가 동시에 진행되어 undefined 값을 가지고 있다.\n<br></br></p>\n<img src=\"https://images.velog.io/images/moon3356/post/5d372a56-7ab7-4a3c-a85c-cde3049f5c60/Moon%20(2).jpg\" width=\"400\">\n<p>평가 과정이 끝나면, 이미 실행되었던 코드들을 제외한 나머지 코드들을 실행한다.</p>\n<p>실행되는 순서대로 예시 코드를 나타내보자면 다음과 같다.</p>\n<pre class=\"grvsc-container one-dark-pro\" data-language=\"javascript\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">var</span><span class=\"mtk1\"> </span><span class=\"mtk4\">test</span><span class=\"mtk1\">; </span><span class=\"mtk8\">-&gt;</span><span class=\"mtk1\"> </span><span class=\"mtk4\">선언</span><span class=\"mtk1\">, </span><span class=\"mtk4\">초기화</span><span class=\"mtk1\"> </span><span class=\"mtk4\">단계를</span><span class=\"mtk1\"> </span><span class=\"mtk4\">마쳐서</span><span class=\"mtk1\"> </span><span class=\"mtk4\">undefined를</span><span class=\"mtk1\"> </span><span class=\"mtk4\">가지고</span><span class=\"mtk1\"> </span><span class=\"mtk4\">있음</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">console</span><span class=\"mtk1\">.</span><span class=\"mtk3\">log</span><span class=\"mtk1\">(</span><span class=\"mtk4\">test</span><span class=\"mtk1\">) </span><span class=\"mtk5 mtki\">// undefined</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">test</span><span class=\"mtk1\"> </span><span class=\"mtk8\">=</span><span class=\"mtk1\"> </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">선언</span><span class=\"mtk1\">, </span><span class=\"mtk4\">초기화</span><span class=\"mtk1\"> </span><span class=\"mtk4\">단계를</span><span class=\"mtk1\"> </span><span class=\"mtk4\">마치고</span><span class=\"mtk1\"> </span><span class=\"mtk4\">마지막으로</span><span class=\"mtk1\"> </span><span class=\"mtk4\">값을</span><span class=\"mtk1\"> </span><span class=\"mtk4\">할당한다</span><span class=\"mtk1\">.</span></span></span></code></pre>\n<p>위와 같이 var test는 호이스팅이 적용되어 유효범위 최상단에 끌어올려지듯이 코드가 실행된다.</p>\n<hr>\n<h2>TDZ(Temporal Dead Zone)란?</h2>\n<p>TDZ는 <strong>일시적 사각지대</strong>라고 하며, 변수가 가지고 있는 스코프 시작 지점부터 초기화 시작 지점까지 참조할 수 없는 곳이 있는데 이 구간을 TDZ라고 부른다.</p>\n<p>이 TDZ는 let과 const에서만 존재하며, var를 사용한다면 TDZ는 존재하지 않는다. 이는 호이스팅 방식의 차이 때문인데, 아래 예제 코드에서 확인해보자.</p>\n<pre class=\"grvsc-container one-dark-pro\" data-language=\"javascript\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">console</span><span class=\"mtk1\">.</span><span class=\"mtk3\">log</span><span class=\"mtk1\">(</span><span class=\"mtk4\">test</span><span class=\"mtk1\">) </span><span class=\"mtk5 mtki\">// undefined</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">var</span><span class=\"mtk1\"> </span><span class=\"mtk4\">test</span><span class=\"mtk1\"> </span><span class=\"mtk8\">=</span><span class=\"mtk1\"> </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span></code></pre>\n<p><strong>var</strong>로 선언한 변수는 <strong>선언, 초기화 단계가 동시에 이루어진다.</strong> 때문에 test를 참조하는 시점에 undefined가 이미 할당이 되어진 상태라 참조 오류가 발생하지 않는다.</p>\n<pre class=\"grvsc-container one-dark-pro\" data-language=\"javascript\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">console</span><span class=\"mtk1\">.</span><span class=\"mtk3\">log</span><span class=\"mtk1\">(</span><span class=\"mtk4\">test</span><span class=\"mtk1\">) </span><span class=\"mtk5 mtki\">// Uncaught ReferenceError</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">let</span><span class=\"mtk1\"> </span><span class=\"mtk4\">test</span><span class=\"mtk1\"> </span><span class=\"mtk8\">=</span><span class=\"mtk1\"> </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">const</span><span class=\"mtk1\"> </span><span class=\"mtk11\">test2</span><span class=\"mtk1\"> </span><span class=\"mtk8\">=</span><span class=\"mtk1\"> </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span></code></pre>\n<p>그러나 <strong>let, const</strong>로 선언한 변수는 <strong>선언 단계와 초기화 단계가 분리되어있다</strong>. 따라서 test를 참조하는 시점에 초기화가 되어있지 않은 상태이기 때문에 참조 오류가 발생하게 된다. 이 참조 오류가 발생하는 구간, 즉 let, const 변수가 가지고 있는 스코프 시작 지점부터 초기화 시작 지점까지의 구간을 TDZ라고 부른다.</p>\n<hr>\n<h2>var와 let, const의 차이점</h2>\n<p>위에서 변수들을 언급한김에 차이점도 함께 정리하려한다.</p>\n<p>우선 var와 let, const의 가장 큰 차이점은 선언 방식의 차이점이다.<br></br></p>\n<h3>선언 방식의 차이</h3>\n<p><strong>1. var (재선언 가능)</strong>\nvar는 재선언이 가능하다는 특징을 가지고 있다. 때문에 다음과 같이 같은 이름의 변수를 두 번 선언하더라도 에러가 발생하지 않는다.</p>\n<pre class=\"grvsc-container one-dark-pro\" data-language=\"javascript\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">var</span><span class=\"mtk1\"> </span><span class=\"mtk4\">a</span><span class=\"mtk1\"> </span><span class=\"mtk8\">=</span><span class=\"mtk1\"> </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">var</span><span class=\"mtk1\"> </span><span class=\"mtk4\">a</span><span class=\"mtk1\"> </span><span class=\"mtk8\">=</span><span class=\"mtk1\"> </span><span class=\"mtk7\">3</span><span class=\"mtk1\">; </span><span class=\"mtk4\">에러</span><span class=\"mtk1\"> </span><span class=\"mtk4\">발생</span><span class=\"mtk1\"> </span><span class=\"mtk11\">X</span></span></span></code></pre>\n<p>프로젝트 규모가 작거나, 간단한 테스트에서라면 재선언을 하면서 편리하게 사용할 수도 있다. 하지만 코드량이 많아지게 된다면, 언제 어디서 선언 됐는지 파악하기 힘들뿐더러 의도치 않게 값이 변경될 가능성도 있다.</p>\n<p>이러한 문제점을 해결하기 위해 자바스크립트 es6 문법에서 새롭게 등장한 것이 let과 const이다.\n<br></br></p>\n<p><strong>2. let (재선언 불가)</strong></p>\n<p>let은 재선언은 불가하지만 재할당이 가능하여 변수를 선언한 이후에 언제든 값을 변경할 수 있다.</p>\n<pre class=\"grvsc-container one-dark-pro\" data-language=\"javascript\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">let</span><span class=\"mtk1\"> </span><span class=\"mtk4\">test</span><span class=\"mtk1\"> </span><span class=\"mtk8\">=</span><span class=\"mtk1\"> </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">test</span><span class=\"mtk1\"> </span><span class=\"mtk8\">=</span><span class=\"mtk1\"> </span><span class=\"mtk7\">3</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk11\">console</span><span class=\"mtk1\">.</span><span class=\"mtk3\">log</span><span class=\"mtk1\">(</span><span class=\"mtk4\">test</span><span class=\"mtk1\">) </span><span class=\"mtk5 mtki\">// 3</span></span></span></code></pre>\n<p><br></br></p>\n<p><strong>3. const (재선언 불가)</strong></p>\n<p>const는 재선언, 재할당 모두 불가능하여 변수를 선언하고 초기에 할당된 값을 변경할 수 없다.</p>\n<pre class=\"grvsc-container one-dark-pro\" data-language=\"javascript\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk10\">const</span><span class=\"mtk1\"> </span><span class=\"mtk11\">test</span><span class=\"mtk1\"> </span><span class=\"mtk8\">=</span><span class=\"mtk1\"> </span><span class=\"mtk7\">1</span><span class=\"mtk1\">;</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk4\">test</span><span class=\"mtk1\"> </span><span class=\"mtk8\">=</span><span class=\"mtk1\"> </span><span class=\"mtk7\">3</span><span class=\"mtk1\">; </span><span class=\"mtk5 mtki\">// Uncaught TypeError: Assignment to constant variable.</span></span></span></code></pre>\n<hr></hr>\n<h2>Reference</h2>\n<p>모던 자바스크립트 Deep Dive\n<br></br></p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .one-dark-pro {\n    background-color: #282c34;\n    color: #abb2bf;\n  }\n  .one-dark-pro .mtki { font-style: italic; }\n  .one-dark-pro .mtk11 { color: #E5C07B; }\n  .one-dark-pro .mtk1 { color: #ABB2BF; }\n  .one-dark-pro .mtk3 { color: #61AFEF; }\n  .one-dark-pro .mtk4 { color: #E06C75; }\n  .one-dark-pro .mtk10 { color: #C678DD; }\n  .one-dark-pro .mtk8 { color: #56B6C2; }\n  .one-dark-pro .mtk7 { color: #D19A66; }\n  .one-dark-pro .mtk5 { color: #7F848E; }\n  .one-dark-pro .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%B3%80%EC%88%98%EB%9E%80\">변수란?</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B3%80%EC%88%98%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94\">변수를 이용하는 이유는?</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8-%EC%B4%88%EA%B8%B0%ED%99%94-%ED%95%A0%EB%8B%B9-%EB%8B%A8%EA%B3%84\">변수 선언, 초기화, 할당 단계</a></p>\n<ul>\n<li><a href=\"#%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8\">변수 선언</a></li>\n<li><a href=\"#%EB%B3%80%EC%88%98-%EC%B4%88%EA%B8%B0%ED%99%94\">변수 초기화</a></li>\n<li><a href=\"#%EB%B3%80%EC%88%98-%ED%95%A0%EB%8B%B9\">변수 할당</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%9D%B4%EB%9E%80\">호이스팅이란?</a></p>\n<ul>\n<li><a href=\"#%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EA%B3%BC%EC%A0%95\">호이스팅이 일어나는 과정</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#tdztemporal-dead-zone%EB%9E%80\">TDZ(Temporal Dead Zone)란?</a></p>\n</li>\n<li>\n<p><a href=\"#var%EC%99%80-let-const%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\">var와 let, const의 차이점</a></p>\n<ul>\n<li><a href=\"#%EC%84%A0%EC%96%B8-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EC%B0%A8%EC%9D%B4\">선언 방식의 차이</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#reference\">Reference</a></p>\n</li>\n</ul>","frontmatter":{"date":"August 10, 2020","slug":"/javascript/post-1/","title":"변수 생성 과정, 호이스팅 정리"}}},"pageContext":{"id":"b8507b37-522f-524f-9750-fa6efa35e1f7","frontmatter__slug":"/javascript/post-1/","__params":{"frontmatter__slug":"javascript"}}},"staticQueryHashes":[]}